# Written by Joyce Tipping <joyce@joycetipping.com>
# License: MIT <http://www.opensource.org/licenses/mit-license.php>
#
# This library includes helpful functions for approximating the binomial with the skew normal

from __future__ import division
from rpy import r
import math
r.library('sn')


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
# Binomial
#
def binomial_pmf (n, p, pairs=False):
  x = r.seq(0, n)
  y = r.dbinom(x, n, p)
  return pair(x, y) if pairs else {'x':x, 'y':y}


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
# Normal Approximation
#
def normal_pdf (n, p, pairs=False):
  (mu, sigma) = normal_params(n, p)
  x = r.seq(-n/2.0, 1.5*n, 0.1)
  y = r.dnorm(x, mu, sigma)
  return pair(x, y) if pairs else {'x':x, 'y':y}

def normal_params (n, p):
  return ( n*p, math.sqrt(n*p*(1.0-p)) )


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
# Skew-normal Approximation
#
def sn_pdf (n, p, pairs=False):
  (mu, sigma, skew) = sn_params(n, p)
  x = r.seq(-n/2.0, 1.5*n, 0.1)
  y = r.dsn(x, mu, sigma, skew)
  return pair(x, y) if pairs else {'x':x, 'y':y}

def sn_p_range (n):
  a = 1/2
  b = 1/2 * math.sqrt(n/(n+4))
  return (a-b, a+b)

def sn_params (n, p):
 return ( sn_mu(n, p), sn_sigma(n,p), sn_skew(n, p) )

def sn_skew (n, p):
  if (p == 0.5): return 0
  else:
    # The left-hand-side is a decreasing function of the skew parameter
    def lhs (skew):
      a = 2.0 / math.pi
      b = skew**2 / (1.0 + skew**2)
      return (1.0 - a*b)**3 / (a * b**3 * (2.0*a - 1.0)**2)

    # The right-hand-side is a constant in n and p
    rhs = n * p * (1.0 - p) / (1.0 - 2.0*p)**2

    # Find upper and lower bounds
    left_bound = right_bound = 1
    while (lhs(left_bound)  < rhs): left_bound  /= 2.0
    while (lhs(right_bound) > rhs): right_bound *= 2.0

    # Calculate the skew (to within 0.00001) by repeatedly bisecting our range
    skew = (right_bound + left_bound) / 2.0
    diff = rhs - lhs(skew)
    while (math.fabs(diff) > 0.00001):
      if (diff > 0):
        right_bound = skew
        skew = (right_bound + left_bound) / 2.0
      else:
        left_bound = skew
        skew = (right_bound + left_bound) / 2.0
      diff = rhs - lhs(skew)

    # Determine the sign from (1 - 2p)
    if (1.0 - 2.0*p < 0): skew *= -1.0
    return skew

def sn_sigma (n, p):
  skew = sn_skew(n, p)
  a = 2.0 / math.pi
  b = skew**2 / (1.0 + skew**2)
  return math.sqrt( n*p*(1-p) / (1 - a*b) )

def sn_mu (n, p):
  sigma = sn_sigma(n, p)
  skew  = sn_skew(n,p)
  c = math.sqrt( 2.0 / math.pi )
  d = skew / math.sqrt(1.0 + skew**2)
  return n*p - sigma*c*d


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
# MABS
#
def mabs_sn (n, p):
  (mu, sigma, skew) = sn_params(n, p)
  def diff (k): return r.pbinom(k, n, p) - r.psn(k+0.5, mu, sigma, skew)
  return max(map(diff, range(n+1)))

def mabs_normal (n, p):
  (mu, sigma) = normal_params(n, p)
  def diff (k): return r.pbinom(k, n, p) - r.pnorm(k+0.5, mu, sigma)
  return max(map(diff, range(n+1)))


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
# General helper functions
#
def pair (xs, ys): return map(lambda x, y: [x, y], xs, ys)
